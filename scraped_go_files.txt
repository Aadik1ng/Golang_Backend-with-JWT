File: D:\daily-expenses\api\expense.go
---
package api

import (
	"daily-expenses/internal/expense"

	"github.com/gorilla/mux"
)

func RegisterExpenseRoutes(r *mux.Router) {
	r.HandleFunc("/expenses", expense.AddExpense).Methods("POST")
	r.HandleFunc("/expenses/{userId}", expense.GetUserExpenses).Methods("GET")
	r.HandleFunc("/all-expenses", expense.HandleFetchAllExpenses).Methods("GET")
	r.HandleFunc("/balance-sheet", expense.HandleDownloadBalanceSheet).Methods("GET")
}

---

File: D:\daily-expenses\api\login.go
---
package api

import (
	"daily-expenses/auth"
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/dgrijalva/jwt-go"
)

var jwtKey = []byte("my_secret_key")

type Credentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func Login(w http.ResponseWriter, r *http.Request) {
	log.Println("Login endpoint called")
	var creds Credentials
	err := json.NewDecoder(r.Body).Decode(&creds)
	if err != nil {
		log.Println("Error decoding request body:", err)
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}

	// Use actual authentication logic here
	if creds.Username != "user" || creds.Password != "user@1" {
		log.Println("Invalid credentials")
		http.Error(w, "Invalid credentials", http.StatusUnauthorized)
		return
	}

	// Hardcoded user ID for demonstration purposes
	userID := "1bc9e841-79f8-4050-88ea-76bd799326ae"

	expirationTime := time.Now().Add(24 * time.Hour)
	claims := &auth.Claims{
		UserID: userID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		log.Println("Error signing token:", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   tokenString,
		Expires: expirationTime,
	})

	json.NewEncoder(w).Encode(map[string]string{"token": tokenString})
}

---

File: D:\daily-expenses\api\user.go
---
package api

import (
	"daily-expenses/internal/user"

	"github.com/gorilla/mux"
)

func RegisterUserRoutes(r *mux.Router) {
	r.HandleFunc("/login", Login).Methods("POST")
	r.HandleFunc("/users", user.CreateUser).Methods("POST")
	r.HandleFunc("/users/{id}", user.GetUser).Methods("GET")
}

---

File: D:\daily-expenses\auth\auth_middleware.go
---
package auth

import (
	"context"
	"fmt"
	"net/http"
	"strings"

	"github.com/dgrijalva/jwt-go"
)

// Define context key type to avoid collisions
type contextKey string

const ContextUserID contextKey = "userID"

type Claims struct {
	UserID string `json:"userId"`
	jwt.StandardClaims
}

// Mock function to parse token and return user ID
func parseTokenAndGetUserID(token string) (string, error) {
	// For demonstration purposes; replace with actual token parsing logic
	if token == "valid-token" {
		return "1bc9e841-79f8-4050-88ea-76bd799326ae", nil
	}
	return "", fmt.Errorf("invalid token")
}

// Middleware for authentication
func AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("Authorization")
		if token == "" {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		token = strings.TrimPrefix(token, "Bearer ")
		userID, err := parseTokenAndGetUserID(token)
		if err != nil {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		// Set the user ID in the context
		ctx := context.WithValue(r.Context(), ContextUserID, userID)
		r = r.WithContext(ctx)

		next.ServeHTTP(w, r)
	})
}

---

File: D:\daily-expenses\cmd\server\main.go
---
package main

import (
	"daily-expenses/api"
	"daily-expenses/auth"
	"daily-expenses/internal/expense"
	"daily-expenses/internal/user"
	"log"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
)

func main() {
	r := mux.NewRouter()

	// Register user routes
	api.RegisterUserRoutes(r)

	// Initialize sample data
	if err := initializeSampleData(); err != nil {
		log.Fatalf("Error initializing sample data: %v", err)
	}

	// Apply JWT Middleware to routes that need authentication
	apiRoutes := r.PathPrefix("/api").Subrouter()
	apiRoutes.Use(auth.AuthMiddleware) // Ensure middleware is used here

	// Register expense routes
	api.RegisterExpenseRoutes(apiRoutes)

	log.Println("Starting server on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}

func initializeSampleData() error {
	// Predefined UUIDs for consistent testing
	user1ID, err := uuid.Parse("1bc9e841-79f8-4050-88ea-76bd799326ae")
	if err != nil {
		return err
	}
	user2ID, err := uuid.Parse("2bc9e841-79f8-4050-88ea-76bd799326ae")
	if err != nil {
		return err
	}

	// Create users with fixed UUIDs
	if _, err := user.CreateUserService("user1@example.com", "John Doe", "1234567890", user1ID); err != nil {
		return err
	}
	if _, err := user.CreateUserService("user2@example.com", "Jane Doe", "0987654321", user2ID); err != nil {
		return err
	}

	// Create expenses with fixed UUIDs
	if _, err := expense.CreateExpenseService("Dinner", 50.0, "equal", []expense.Participant{
		{UserID: user1ID, Amount: 25.0},
		{UserID: user2ID, Amount: 25.0},
	}); err != nil {
		return err
	}
	if _, err := expense.CreateExpenseService("Taxi", 20.0, "equal", []expense.Participant{
		{UserID: user1ID, Amount: 10.0},
		{UserID: user2ID, Amount: 10.0},
	}); err != nil {
		return err
	}

	return nil
}

---

File: D:\daily-expenses\internal\database\database.go
---
package database

import (
	"daily-expenses/internal/expense"
	"daily-expenses/internal/user"
	"sync"

	"github.com/google/uuid"
)

var (
	Users    = make(map[uuid.UUID]user.User)
	Expenses = make(map[uuid.UUID]expense.Expense)
	mu       sync.Mutex
)

func GetUser(userID uuid.UUID) (user.User, bool) {
	mu.Lock()
	defer mu.Unlock()
	user, exists := Users[userID]
	return user, exists
}

func AddUser(user user.User) {
	mu.Lock()
	defer mu.Unlock()
	Users[user.ID] = user
}

func GetExpense(expenseID uuid.UUID) (expense.Expense, bool) {
	mu.Lock()
	defer mu.Unlock()
	exp, exists := Expenses[expenseID]
	return exp, exists
}

func AddExpense(exp expense.Expense) {
	mu.Lock()
	defer mu.Unlock()
	Expenses[exp.ID] = exp
}

---

File: D:\daily-expenses\internal\expense\handler.go
---
package expense

import (
	"encoding/json"
	"net/http"

	"daily-expenses/internal/middleware"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
)

func AddExpense(w http.ResponseWriter, r *http.Request) {
	// Fetch user ID from the context using the middleware key
	userIDStr, ok := r.Context().Value(middleware.ContextUserID).(string)
	if !ok || userIDStr == "" {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	var expense Expense
	err = json.NewDecoder(r.Body).Decode(&expense)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Add the user ID to participants
	expense.Participants = append(expense.Participants, Participant{UserID: userID})

	createdExpense, err := CreateExpenseService(expense.Description, expense.Amount, expense.SplitMethod, expense.Participants)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(createdExpense)
}

func HandleFetchAllExpenses(w http.ResponseWriter, r *http.Request) {
	allExpenses := FetchAllExpensesService()
	json.NewEncoder(w).Encode(allExpenses)
}

func HandleDownloadBalanceSheet(w http.ResponseWriter, r *http.Request) {
	balanceSheet := DownloadBalanceSheetService()
	w.Header().Set("Content-Disposition", "attachment; filename=balance_sheet.json")
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(balanceSheet)
}

func GetUserExpenses(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	userID, err := uuid.Parse(params["userId"])
	if err != nil {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	expenses := GetUserExpensesService(userID)
	if expenses == nil {
		http.NotFound(w, r)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(expenses)
}

---

File: D:\daily-expenses\internal\expense\model.go
---
package expense

import (
	"time"

	"github.com/google/uuid"
)

type Participant struct {
	UserID     uuid.UUID `json:"userId"`
	Amount     float64   `json:"amount,omitempty"`     // For Exact split method
	Percentage float64   `json:"percentage,omitempty"` // For Percentage split method
}

type Expense struct {
	ID           uuid.UUID     `json:"id"`
	Description  string        `json:"description"`
	Amount       float64       `json:"amount"`
	SplitMethod  string        `json:"splitMethod"`
	Participants []Participant `json:"participants"`
	CreatedAt    time.Time     `json:"CreatedAt"`
}

type UserBalance struct {
	UserID  uuid.UUID `json:"userId"`
	Balance float64   `json:"balance"`
}

type BalanceSheet struct {
	Balances []UserBalance `json:"balances"`
}

---

File: D:\daily-expenses\internal\expense\repository.go
---
package expense

import (
	"sync"

	"github.com/google/uuid"
)

var (
	expenses   = make(map[uuid.UUID]Expense)
	balances   = make(map[uuid.UUID]float64)
	expenseMux sync.Mutex
)

func SaveExpense(expense Expense) {
	expenseMux.Lock()
	defer expenseMux.Unlock()
	expenses[expense.ID] = expense
	for _, participant := range expense.Participants {
		balances[participant.UserID] -= participant.Amount
	}
}

func FetchAllExpenses() []Expense {
	expenseMux.Lock()
	defer expenseMux.Unlock()

	var allExpenses []Expense
	for _, exp := range expenses {
		allExpenses = append(allExpenses, exp)
	}
	return allExpenses
}

func FetchUserExpenses(userID uuid.UUID) []Expense {
	expenseMux.Lock()
	defer expenseMux.Unlock()

	var userExpenses []Expense
	for _, exp := range expenses {
		for _, participant := range exp.Participants {
			if participant.UserID == userID {
				userExpenses = append(userExpenses, exp)
				break
			}
		}
	}
	return userExpenses
}

---

File: D:\daily-expenses\internal\expense\service.go
---
package expense

import (
	"errors"
	"time"

	"github.com/google/uuid"
)

func CreateExpenseService(description string, amount float64, splitMethod string, participants []Participant) (Expense, error) {
	expense := Expense{
		ID:           uuid.New(),
		Description:  description,
		Amount:       amount,
		SplitMethod:  splitMethod,
		Participants: participants,
		CreatedAt:    time.Now(),
	}
	if err := ValidateExpense(expense); err != nil {
		return Expense{}, err
	}

	switch splitMethod {
	case "equal":
		splitEqual(&expense)
	case "exact":
		if err := splitExact(&expense); err != nil {
			return Expense{}, err
		}
	case "percentage":
		if err := splitPercentage(&expense); err != nil {
			return Expense{}, err
		}
	default:
		return Expense{}, errors.New("invalid split method")
	}

	saveExpense(expense)
	return expense, nil
}

func splitPercentageBasedOnValue(expense *Expense, percentage float64) {
	if len(expense.Participants) < 1 {
		return // or handle error
	}
	if len(expense.Participants) == 1 {
		expense.Participants[0].Percentage = 100 - percentage
		expense.Participants = append(expense.Participants, Participant{
			UserID:     uuid.New(),
			Percentage: percentage,
		})
	} else {
		expense.Participants[0].Percentage = 100 - percentage
		expense.Participants = append(expense.Participants, Participant{
			UserID:     uuid.New(),
			Percentage: percentage,
		})
	}
	for i := range expense.Participants {
		expense.Participants[i].Amount = (expense.Amount * expense.Participants[i].Percentage) / 100
	}
}

func FetchAllExpensesService() []Expense {
	expenseMux.Lock()
	defer expenseMux.Unlock()

	var allExpenses []Expense
	for _, exp := range expenses {
		allExpenses = append(allExpenses, exp)
	}
	return allExpenses
}

func DownloadBalanceSheetService() BalanceSheet {
	expenseMux.Lock()
	defer expenseMux.Unlock()

	var balanceSheet BalanceSheet
	for userID, balance := range balances {
		balanceSheet.Balances = append(balanceSheet.Balances, UserBalance{
			UserID:  userID,
			Balance: balance,
		})
	}
	return balanceSheet
}

func GetUserExpensesService(userID uuid.UUID) []Expense {
	expenseMux.Lock()
	defer expenseMux.Unlock()

	var userExpenses []Expense
	for _, exp := range expenses {
		for _, participant := range exp.Participants {
			if participant.UserID == userID {
				userExpenses = append(userExpenses, exp)
				break
			}
		}
	}
	return userExpenses
}

func saveExpense(expense Expense) {
	expenseMux.Lock()
	defer expenseMux.Unlock()

	expenses[expense.ID] = expense
	for _, participant := range expense.Participants {
		balances[participant.UserID] -= participant.Amount
	}
}

func splitEqual(expense *Expense) {
	share := expense.Amount / float64(len(expense.Participants))
	for i := range expense.Participants {
		expense.Participants[i].Amount = share
	}
}

func splitExact(expense *Expense) error {
	total := 0.0
	for _, participant := range expense.Participants {
		total += participant.Amount
	}
	if total != expense.Amount {
		return errors.New("total amount does not match the sum of participants' amounts")
	}
	return nil
}

func splitPercentage(expense *Expense) error {
	total := 0.0
	for _, participant := range expense.Participants {
		total += participant.Percentage
	}
	if total != 100 {
		return errors.New("total percentage does not add up to 100")
	}

	for i := range expense.Participants {
		expense.Participants[i].Amount = (expense.Amount * expense.Participants[i].Percentage) / 100
	}
	return nil
}

---

File: D:\daily-expenses\internal\expense\validation.go
---
package expense

import (
	"errors"
)

func ValidateExpense(expense Expense) error {
	if expense.Description == "" {
		return errors.New("description is required")
	}

	if expense.Amount <= 0 {
		return errors.New("amount must be greater than 0")
	}

	if len(expense.Participants) == 0 {
		return errors.New("at least one participant is required")
	}

	switch expense.SplitMethod {
	case "equal":
		// no additional validation needed
	case "exact":
		total := 0.0
		for _, p := range expense.Participants {
			total += p.Amount
		}
		if total != expense.Amount {
			return errors.New("total exact amounts do not match the expense amount")
		}
	case "percentage":
		total := 0.0
		for _, p := range expense.Participants {
			total += p.Percentage
		}
		if total != 100 {
			return errors.New("total percentages must add up to 100")
		}
	default:
		return errors.New("invalid split method")
	}

	return nil
}

---

File: D:\daily-expenses\internal\middleware\auth.go
---
package middleware

import (
	"context"
	"net/http"
)

// Define a context key type to avoid context key collisions
type contextKey string

const ContextUserID contextKey = "userID"

// MiddlewareAuthenticate authenticates a user and adds their ID to the context
func MiddlewareAuthenticate(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Example authentication logic
		userID := "1bc9e841-79f8-4050-88ea-76bd799326ae" // Replace with actual authentication logic
		ctx := context.WithValue(r.Context(), ContextUserID, userID)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

---

File: D:\daily-expenses\internal\user\handler.go
---
package user

import (
	"encoding/json"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
)

func CreateUser(w http.ResponseWriter, r *http.Request) {
	var user User
	err := json.NewDecoder(r.Body).Decode(&user)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	createdUser, err := CreateUserService(user.Email, user.Name, user.Mobile, user.ID)
	if err != nil {
		http.Error(w, "Invalid Info", http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(createdUser)
}

func GetUser(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	userID, err := uuid.Parse(params["id"])
	if err != nil {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	user := GetUserService(userID)
	if user == nil {
		http.NotFound(w, r)
		return
	}

	json.NewEncoder(w).Encode(user)
}

---

File: D:\daily-expenses\internal\user\model.go
---
package user

import "github.com/google/uuid"

type User struct {
	ID     uuid.UUID `json:"id"`
	Email  string    `json:"email"`
	Name   string    `json:"name"`
	Mobile string    `json:"mobile"`
}

---

File: D:\daily-expenses\internal\user\repository.go
---
package user

import (
	"sync"

	"github.com/google/uuid"
)

var users = make(map[uuid.UUID]User)
var mu sync.Mutex

func SaveUser(user User) {
	mu.Lock()
	defer mu.Unlock()
	users[user.ID] = user
}

func FetchUserByID(userID uuid.UUID) *User {
	mu.Lock()
	defer mu.Unlock()
	if user, exists := users[userID]; exists {
		return &user
	}
	return nil
}

---

File: D:\daily-expenses\internal\user\service.go
---
package user

import (
	"errors"
	"fmt"

	"github.com/google/uuid"
)

func CreateUserService(email, name, mobile string, userID uuid.UUID) (User, error) {
	if email == "" || name == "" || mobile == "" {
		return User{}, errors.New("all fields are required")
	}

	user := User{
		ID:     userID,
		Email:  email,
		Name:   name,
		Mobile: mobile,
	}
	SaveUser(user)
	fmt.Println("User created with UUID:", user.ID)
	return user, nil
}

func GetUserService(userID uuid.UUID) *User {
	return FetchUserByID(userID)
}

---

File: D:\daily-expenses\internal\user\validation.go
---
package user

import (
	"errors"
	"regexp"
)

func ValidateUser(user User) error {
	if user.Email == "" {
		return errors.New("email is required")
	}

	// Simple email regex validation
	emailRegex := regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,}$`)
	if !emailRegex.MatchString(user.Email) {
		return errors.New("invalid email format")
	}

	if user.Name == "" {
		return errors.New("name is required")
	}

	if user.Mobile == "" {
		return errors.New("mobile number is required")
	}

	// Simple mobile number regex validation (assuming 10-digit numbers)
	mobileRegex := regexp.MustCompile(`^\d{10}$`)
	if !mobileRegex.MatchString(user.Mobile) {
		return errors.New("invalid mobile number format")
	}

	return nil
}

---

File: D:\daily-expenses\pkg\middleware\middleware.go
---
package middleware

import (
	"log"
	"net/http"
	"time"
)

func LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		log.Printf("%s %s %s", r.Method, r.RequestURI, time.Since(start))
	})
}

---

File: D:\daily-expenses\pkg\utils\utils.go
---
package utils

import (
	"encoding/json"
	"net/http"
)

func RespondWithJSON(w http.ResponseWriter, status int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(payload)
}

func RespondWithError(w http.ResponseWriter, code int, message string) {
	RespondWithJSON(w, code, map[string]string{"error": message})
}

---

